{
  "name": "model",
  "description": "Datastore-agnostic ORM in JavaScript",
  "keywords": [
    "model",
    "orm",
    "relation",
    "data",
    "mapper",
    "validation",
    "postgresql",
    "postgres",
    "riak",
    "mongo",
    "mongodb"
  ],
  "version": "0.0.24",
  "author": {
    "name": "Matthew Eernisse",
    "email": "mde@fleegix.org",
    "url": "http://fleegix.org"
  },
  "main": "./lib/index.js",
  "scripts": {
    "test": "jake test"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/mde/model.git"
  },
  "dependencies": {
    "utilities": "0.0.x",
    "mongodb-wrapper": "0.4.x",
    "pg": "0.7.x"
  },
  "engines": {
    "node": "*"
  },
  "readme": "Model\n==============\n\n[![build status](https://secure.travis-ci.org/mde/model.png)](http://travis-ci.org/mde/model)\n\nModel is a datastore-agnostic ORM in JavaScript. It serves as the\nmodel-component for the [Geddy MVC Web framework](http://geddyjs.org/) for\nNodeJS.\n\n### License\n\nApache License, Version 2\n\n### Prerequisites\n\nModel requires version 0.6.x of Node.js or higher. If you want to run the tests,\nor work on Model, you'll want the [Jake](https://github.com/mde/jake) JavaScript\nbuild-tool.\n\n### Installing with [NPM](http://npmjs.org/)\n\n```\nnpm install model\n```\n\n## Adapters\n\nModel currently implements adapters for:\n\n* Postgres\n* Riak\n* MongoDB\n\n## Defining models\n\nModel uses a pretty simple syntax for defining a model. (It should look familiar\nto anyone who has used an ORM like ActiveRecord, DataMapper, Django's models, or\nSQLAlchemy.)\n\n```javascript\nvar User = function () {\n  this.property('login', 'string', {required: true});\n  this.property('password', 'string', {required: true});\n  this.property('lastName', 'string');\n  this.property('firstName', 'string');\n\n  this.validatesPresent('login');\n  this.validatesFormat('login', /[a-z]+/, {message: 'Subdivisions!'});\n  this.validatesLength('login', {min: 3});\n  this.validatesConfirmed('password', 'confirmPassword');\n  this.validatesWithFunction('password', function (s) {\n      // Something that returns true or false\n      return s.length > 0;\n  });\n\n  // Can define methods for instances like this\n  this.someMethod = function () {\n    // Do some stuff\n  };\n};\n\n// Can also define them on the prototype\nUser.prototype.someOtherMethod = function () {\n  // Do some other stuff\n};\n\nUser = model.register('User', User);\n```\n\n### Abbreviated syntax\n\nAlternatively, you can use the `defineProperties` method to lay out your model's\nproperties in one go:\n\n```javascript\nvar User = function () {\n  this.defineProperties({\n    login: {type: 'string', required: true}\n  , password: {type: 'string', required: true}\n  , lastName: {type: 'string'}\n  , firstName: {type: 'string'}\n  });\n}\n```\n\n## Creating instances\n\nCreating an instance of one of these models is easy:\n\n```javascript\nvar params = {\n  login: 'alex'\n, password: 'lerxst'\n, lastName: 'Lifeson'\n, firstName: 'Alex'\n};\nvar user = User.create(params);\n```\n\n## Validation and errors\n\nData-validation happens on the call to `create`, and any validation errors show\nup inside an `errors` property on the instance, keyed by field name. Instances\nhave an `isValid` method that returns a Boolean indicating whether the instance is\nvalid.\n\n```javascript\n// Leaving out the required password field\nvar params = {\n  login: 'alex'\n};\nvar user = User.create(params);\n\n// Prints 'false'\nconsole.log(user.isValid());\n// Prints 'Field \"password\" is required'\nconsole.log(user.errors.password);\n```\n\n## Saving items\n\nAfter creating the instance, call the `save` method on the instance. This method\ntakes a callbak in the familiar (err, data) format for Node.\n\n```javascript\nif (user.isValid()) {\n  user.save(function (err, data) {\n    if (err) {\n      throw err;\n    }\n    console.log('New item saved!');\n  });\n}\n```\n\n## Updating items\n\nUse the `updateProperties` method to update the values of the properties on an\ninstance with the appropriate validations. Then call `save` on the instance.\n\n```javascript\nuser.updateProperties({\n  login: 'alerxst'\n});\nif (user.isValid()) {\n  user.save(function (err, data) {\n    if (err) {\n      throw err;\n    }\n    console.log('Item updated!');\n  });\n}\n```\n\n## Lifecycle events\n\nBoth the base model 'constructors,' and model instances are EventEmitters. The\nemit events during the create/update/remove lifecycle of model instances. In all\ncases, the plain-named event is fired after the event in question, the\n'before'-prefixed event, of course happens before.\n\nThe 'constructor' for a model emits the following events:\n\n * beforeCreate\n * create\n * beforeValidate\n * validate\n * beforeUpdateProperties\n * updateProperties\n * beforeSave (new instances, single and bulk)\n * save (new instances, single and bulk)\n * beforeUpdate (existing single instances, bulk updates)\n * update (existing single instances, bulk updates)\n * beforeRemove\n * remove\n\nModel-item instances emit these events:\n\n * beforeUpdateProperties\n * updateProperties\n * beforeSave\n * save\n * beforeUpdate\n * update\n\n## Querying\n\nModel uses a simple API for finding and sorting items. Again, it should look\nfamiliar to anyone who has used a similar ORM for looking up records. The only\nwrinkle with Model is that the API is (as you might expect for a NodeJS library)\nasynchronous.\n\nMethods for querying are static methods on each model constructor.\n\n### Finding a single item\n\nUse the `first` method to find a single item. You can pass it an id, or a set of\nquery parameters in the form of an object-literal. In the case of a query, it\nwill return the first item that matches, according to whatever sort you've\nspecified.\n\n```javascript\nvar user;\nUser.first({login: 'alerxst'}, function (err, data) {\n  if (err) {\n    throw err;\n  }\n  user = data;\n  console.log('Found user');\n  console.dir(user);\n});\n```\n\n### Collections of items\n\nUse the `all` method to find lots of items. Pass it a set of query parameters in\nthe form of an object-literal, where each key is a field to compare, and the\nvalue is either a simple value for comparison (equal to), or another\nobject-literal where the key is the comparison-operator, and the value is the\nvalue to use for the comparison.\n\n```javascript\nvar users\n  , dt;\n\ndt = new Date();\ndt.setHours(dt.getHours() - 24);\n\n// Find all the users created since yesterday\nUser.all({createdAt: {gt: dt}, function (err, data) {\n  if (err) {\n    throw err;\n  }\n  users = data;\n  console.log('Found users');\n  console.dir(users);\n});\n```\n\nHere are some more examples of queries:\n\n```javascript\n// Where \"foo\" is 'BAR' and \"bar\" is not null\n{foo: 'BAR', bar: {ne: null}}\n// Where \"foo\" begins with 'B'\n{foo: {'like': 'B'}}\n// Where foo is less than 2112, and bar is 'BAZ'\n{foo: {lt: 2112}, bar: 'BAZ'}\n```\n\n### Comparison operators\n\nHere is the list of comparison operators currently supported:\n\neql: equal to\nne: not equal to\ngt: greater than\nlt: less than\ngte: greater than or equal\nlte: less than or equal\nlike: like\n\nA simple string-value for a query parameter is the same as 'eql'. `{foo: 'bar'}`\nis the same as `{foo: {eql: 'bar'}}`.\n\n## More complex queries\n\nModel supports combining queries with OR and negating queries with NOT.\n\nTo perform an 'or' query, use an object-literal with a key of 'or', and an array\nof query-objects to represent each set of alternative conditions:\n\n```javascript\n// Where \"foo\" is 'BAR' OR \"bar\" is 'BAZ'\n{or: [{foo: 'BAR'}, {bar: 'BAZ'}]}\n// Where \"foo\" is not 'BAR' OR \"bar\" is null OR \"baz\" is less than 2112\n{or: [{foo {ne: 'BAR'}}, {bar: null}, {baz: {lt: 2112}}]}\n```\n\nTo negate a query with 'not', simply use a query-object where 'not' is the key,\nand the value is the set of conditions to negate:\n\n```javascript\n// Where NOT (\"foo\" is 'BAR' and \"bar\" is 'BAZ')\n{not: {foo: 'BAR', bar: 'BAZ'}}\n// Where NOT (\"foo\" is 'BAZ' and \"bar\" is less than 1001)\n{not: {foo: 'BAZ', bar: {lt: 1001}}}\n```\n\nThese OR and NOT queries can be nested and combined:\n\n```javascript\n// Where (\"foo\" is like 'b' OR \"foo\" is 'foo') and NOT \"foo\" is 'baz'\n{or: [{foo: {'like': 'b'}}, {foo: 'foo'}], not: {foo: 'baz'}}\n```\n\n## Sorting\n\nThe `all` API-call for querying accepts an optional options-object after the\nquery-conditions. Set a 'sort' in that options-object to specifiy properties to\nsort on, and the sort-direction for each one.\n\n```javascript\nvar users\n// Find all the users who have ever been updated, and sort by\n// creation-date, ascending, then last name, descending\nUser.all({updatedAt: {ne: null}}, {sort: {createdAt: 'asc', lastName: 'desc'}},\n    function (err, data) {\n  if (err) {\n    throw err;\n  }\n  users = data;\n  console.log('Updated users');\n  console.dir(users);\n});\n```\n\n### Simplified syntax\n\nYou can use a simplified syntax for specifying the sort. The default\nsort-direction is ascending ('asc'), so you can specify a property to sort on\n(or multiple properties as an array) if you want all sorts to be ascending:\n\n```javascript\n// Sort by createdAt, ascending\n{sort: 'createdAt'}\n// Sort by createdAt, then updatedAt, then lastName,\n// then firstName -- all ascending\n{sort: ['createdAt', 'updatedAt', 'lastName', 'firstName']}\n\n```\n\n## Associations\n\nModel has basic support for associations: including hasMany/belongsTo and\nhasOne/belongsTo. For example, if you had a `User` model with a single\n`Profile`, and potentially many `Accounts`:\n\n```javascript\nvar User = function () {\n  this.property('login', 'string', {required: true});\n  this.property('password', 'string', {required: true});\n  this.property('confirmPassword', 'string', {required: true});\n\n  this.hasOne('Profile');\n  this.hasMany('Accounts');\n};\n```\n\nA `Book` model that belongs to an `Author` would look like this:\n\n```javascript\nvar Book = function () {\n  this.property('title', 'string');\n  this.property('description', 'text');\n\n  this.belongsTo('Author');\n};\n```\n\nAdd the `hasOne` relationship by calling 'set' plus the name of the owned\nmodel in singular (in this case `setProfile`). Retrieve the associated item by\nusing 'get' plus the name of the owned model in singular (in this case\n`getProfile`). Here's an example:\n\n```javascript\nvar user = User.create({\n  login: 'asdf'\n, password: 'zerb'\n, confirmPassword: 'zerb'\n});\nuser.save(function (err, data) {\n  if (err) {\n    throw err;\n  }\n  user.setProfile(Profile.create({}));\n  user.save(function (err, data) {\n    if (err) {\n      throw err;\n    }\n    user.getProfile(function (err, data) {\n      if (err) {\n        throw err;\n      }\n      console.log(profile.id ' is the same as ' + data.id);\n    });\n  });\n});\n```\n\nSet up the `hasMany` relationship by calling 'add' plus the name of the\nowned model in singular (in this case `addAccount`). Retrieve the associated\nitems with a call to 'get' plus the name of the owned model in plural (in\nthis case `getAccounts`). An example:\n\n```javascript\nvar user = User.create({\n  login: 'asdf'\n, password: 'zerb'\n, confirmPassword: 'zerb'\n});\nuser.save(function (err, data) {\n  if (err) {\n    throw err;\n  }\n  user.addAccount(Account.create({}));\n  user.addAccount(Account.create({}));\n  user.save(function (err, data) {\n    if (err) {\n      throw err;\n    }\n    user.getAccounts(function (err, data) {\n      if (err) {\n        throw err;\n      }\n      console.log('This number should be 2: ' + data.length);\n    });\n  });\n});\n```\n\nA `belongsTo` relationship is created similarly to a `hasOne`: by calling 'set'\nplus the name of the owner model in singular (in this case `setAuthor`).\nRetrieve the associated item by using 'get' plus the name of the owner model\nin singular (in this case `getAuthor`). Here's an example:\n\n```javascript\nvar book = Book.create({\n  title: 'How to Eat an Entire Ham'\n, description: 'Such a poignant book. I cried.'\n});\nbook.save(function (err, data) {\n  if (err) {\n    throw err;\n  }\n  book.setAuthor(Author.create({\n    familyName: 'Neeble'\n  , givenName: 'Leonard'\n  }));\n  book.save(function (err, data) {\n    if (err) {\n      throw err;\n    }\n    book.getAuthor(function (err, data) {\n      if (err) {\n        throw err;\n      }\n      console.log('This name should be \"Neeble\": ' + data.familyName);\n    });\n  });\n});\n```\n\n### Named associations\n\nSometimes you need mutliple associations to the same type of model (e.g., I have\nlots of Friends and Relatives who are all Users). You can accomplish this in\nModel using named associations:\n\n```javascript\nvar User = function () {\n  this.property('familyName', 'string', {required: true});\n  this.property('givenName', 'string', {required: true});\n\n  this.hasMany('Friends', {model: 'Users'});\n  this.hasMany('Relatives', {model: 'Users'});\n};\n```\n\nThe API for this is the same as with normal associations, using the `set`/`add`\nand `get`, with the appropriate association name (not the model name). For\nexample, in the case of `Friends`, you'd use `addFriend` and `getFriends`.\n\n- - -\nModel JavaScript ORM copyright 2112 mde@fleegix.org.\n\n\n\n",
  "_id": "model@0.0.24",
  "dist": {
    "shasum": "0a64f99e8310b2e6c7747827c49b4e248ac5bb7b"
  },
  "_from": "model@0.0.x"
}
